# GitHub Actions workflow for compiling Arduino firmware
# ç”¨äºŽç¼–è¯‘ Arduino å›ºä»¶çš„ GitHub Actions å·¥ä½œæµ
#
# This workflow automatically compiles all firmware examples for different boards
# and creates releases with the compiled binaries for web flashing.
# æ­¤å·¥ä½œæµè‡ªåŠ¨ä¸ºä¸åŒå¼€å‘æ¿ç¼–è¯‘æ‰€æœ‰å›ºä»¶ç¤ºä¾‹ï¼Œå¹¶åˆ›å»ºåŒ…å«ç¼–è¯‘å¥½çš„äºŒè¿›åˆ¶æ–‡ä»¶çš„å‘å¸ƒç‰ˆæœ¬ï¼Œç”¨äºŽç½‘é¡µçƒ§å½•ã€‚

name: Build Firmware

on:
  push:
    branches: [main, master]
    paths:
      - 'arduino/**'
      - '.github/workflows/build-firmware.yml'
  pull_request:
    paths:
      - 'arduino/**'
  workflow_dispatch:  # Allow manual trigger | å…è®¸æ‰‹åŠ¨è§¦å‘
    inputs:
      release:
        description: 'Create a release with firmware binaries'
        required: false
        default: 'false'
        type: boolean

env:
  ARDUINO_CLI_VERSION: "0.35.3"
  ESP32_CORE_VERSION: "3.3.4"  # Lock ESP32 Core version for build consistency | é”å®š ESP32 Core ç‰ˆæœ¬ä»¥ç¡®ä¿æž„å»ºä¸€è‡´æ€§

jobs:
  build:
    runs-on: ubuntu-latest
    
    strategy:
      fail-fast: false
      matrix:
        include:
          # ESP32-C6 based products | åŸºäºŽ ESP32-C6 çš„äº§å“
          - firmware: "IoTButtonV2_DeepSleep"
            sketch: "arduino/SeeedHADiscovery/examples/IoTButtonV2_DeepSleep/IoTButtonV2_DeepSleep.ino"
            board: "esp32:esp32:esp32c6"
            board_options: "CDCOnBoot=cdc,PartitionScheme=huge_app,CPUFreq=80,FlashMode=qio,FlashSize=4M,UploadSpeed=921600"
            platform: "esp32:esp32"
            platform_url: "https://espressif.github.io/arduino-esp32/package_esp32_index.json"
            
          # ESP32-S3 based products (example) | åŸºäºŽ ESP32-S3 çš„äº§å“ï¼ˆç¤ºä¾‹ï¼‰
          - firmware: "WiFiProvisioning"
            sketch: "arduino/SeeedHADiscovery/examples/WiFiProvisioning/WiFiProvisioning.ino"
            board: "esp32:esp32:esp32c6"
            board_options: "CDCOnBoot=cdc,PartitionScheme=huge_app,CPUFreq=80,FlashMode=qio,FlashSize=4M,UploadSpeed=921600"
            platform: "esp32:esp32"
            platform_url: "https://espressif.github.io/arduino-esp32/package_esp32_index.json"
            
          # Add more firmware configurations here | åœ¨æ­¤æ·»åŠ æ›´å¤šå›ºä»¶é…ç½®
          # - firmware: "CameraStream"
          #   sketch: "arduino/SeeedHADiscovery/examples/CameraStream/CameraStream.ino"
          #   board: "esp32:esp32:esp32s3"
          #   board_options: "..."
          #   platform: "esp32:esp32"
          #   platform_url: "https://espressif.github.io/arduino-esp32/package_esp32_index.json"

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Arduino CLI
        run: |
          # Download and install Arduino CLI manually (more reliable)
          # æ‰‹åŠ¨ä¸‹è½½å®‰è£… Arduino CLIï¼ˆæ›´å¯é ï¼‰
          curl -fsSL https://raw.githubusercontent.com/arduino/arduino-cli/master/install.sh | BINDIR=/usr/local/bin sh
          arduino-cli version

      - name: Install platform and libraries
        run: |
          # Add board manager URL | æ·»åŠ å¼€å‘æ¿ç®¡ç†å™¨ URL
          arduino-cli config init
          arduino-cli config add board_manager.additional_urls "${{ matrix.platform_url }}"
          
          # Update index and install platform with locked version | æ›´æ–°ç´¢å¼•å¹¶å®‰è£…é”å®šç‰ˆæœ¬çš„å¹³å°
          arduino-cli core update-index
          arduino-cli core install ${{ matrix.platform }}@${{ env.ESP32_CORE_VERSION }}
          
          echo "Installed ESP32 Core version: ${{ env.ESP32_CORE_VERSION }}"
          
          # Install required libraries | å®‰è£…æ‰€éœ€åº“
          arduino-cli lib install "ArduinoJson"
          arduino-cli lib install "WebSockets"
          arduino-cli lib install "Adafruit NeoPixel"
          
          # Install SeeedHADiscovery library from local | ä»Žæœ¬åœ°å®‰è£… SeeedHADiscovery åº“
          mkdir -p ~/Arduino/libraries
          cp -r arduino/SeeedHADiscovery ~/Arduino/libraries/

      - name: Compile firmware
        run: |
          mkdir -p build/${{ matrix.firmware }}
          
          # Compile the sketch | ç¼–è¯‘å›ºä»¶
          arduino-cli compile \
            --fqbn "${{ matrix.board }}:${{ matrix.board_options }}" \
            --output-dir "build/${{ matrix.firmware }}" \
            --export-binaries \
            "${{ matrix.sketch }}"
          
          # List compiled files | åˆ—å‡ºç¼–è¯‘çš„æ–‡ä»¶
          echo "Compiled files:"
          ls -la build/${{ matrix.firmware }}/

      - name: Prepare firmware files for ESP Web Tools
        run: |
          cd build/${{ matrix.firmware }}
          
          # Rename files for clarity | é‡å‘½åæ–‡ä»¶ä»¥ä¾¿è¯†åˆ«
          # ESP32 typically outputs: sketch.ino.bin, sketch.ino.bootloader.bin, sketch.ino.partitions.bin
          for f in *.bin; do
            if [[ "$f" == *".ino.bin" ]]; then
              mv "$f" "firmware.bin"
            elif [[ "$f" == *".bootloader.bin" ]]; then
              mv "$f" "bootloader.bin"
            elif [[ "$f" == *".partitions.bin" ]]; then
              mv "$f" "partitions.bin"
            fi
          done
          
          # Copy boot_app0.bin from ESP32 Core (required for OTA boot selection)
          # ä»Ž ESP32 Core å¤åˆ¶ boot_app0.binï¼ˆOTA å¯åŠ¨é€‰æ‹©æ‰€éœ€ï¼‰
          # This file is at offset 0xe000 and is needed for proper boot sequence
          # æ­¤æ–‡ä»¶åœ¨åç§»åœ°å€ 0xe000ï¼Œæ­£ç¡®å¯åŠ¨åºåˆ—æ‰€éœ€
          ESP32_CORE_PATH=$(find ~/.arduino15/packages/esp32/hardware/esp32 -maxdepth 1 -type d -name "${{ env.ESP32_CORE_VERSION }}" | head -1)
          if [ -n "$ESP32_CORE_PATH" ] && [ -f "$ESP32_CORE_PATH/tools/partitions/boot_app0.bin" ]; then
            cp "$ESP32_CORE_PATH/tools/partitions/boot_app0.bin" ./boot_app0.bin
            echo "âœ“ Copied boot_app0.bin from ESP32 Core"
          else
            echo "âš  Warning: boot_app0.bin not found, trying alternative path..."
            # Alternative search | å¤‡é€‰æœç´¢è·¯å¾„
            BOOT_APP0=$(find ~/.arduino15/packages/esp32 -name "boot_app0.bin" -type f | head -1)
            if [ -n "$BOOT_APP0" ]; then
              cp "$BOOT_APP0" ./boot_app0.bin
              echo "âœ“ Copied boot_app0.bin from: $BOOT_APP0"
            else
              echo "âœ— Error: boot_app0.bin not found!"
              exit 1
            fi
          fi
          
          # List final files | åˆ—å‡ºæœ€ç»ˆæ–‡ä»¶
          echo "Final firmware files:"
          ls -la

      - name: Create manifest.json for ESP Web Tools
        run: |
          cd build/${{ matrix.firmware }}
          
          # Determine chip family and offsets based on board | æ ¹æ®å¼€å‘æ¿ç¡®å®šèŠ¯ç‰‡ç³»åˆ—å’Œåç§»åœ°å€
          # ESP32-C3/C6/S3/H2 use 0x0 for bootloader | ESP32-C3/C6/S3/H2 çš„ bootloader åç§»ä¸º 0x0
          # Original ESP32/ESP32-S2 use 0x1000 | åŽŸç‰ˆ ESP32/ESP32-S2 çš„åç§»ä¸º 0x1000
          
          CHIP_FAMILY="ESP32-C6"
          BOOTLOADER_OFFSET=0
          PARTITIONS_OFFSET=32768   # 0x8000
          BOOT_APP0_OFFSET=57344    # 0xe000 - OTA boot selection | OTA å¯åŠ¨é€‰æ‹©
          FIRMWARE_OFFSET=65536     # 0x10000
          
          if [[ "${{ matrix.board }}" == *"esp32s3"* ]] || [[ "${{ matrix.board }}" == *"XIAO_ESP32S3"* ]]; then
            CHIP_FAMILY="ESP32-S3"
            BOOTLOADER_OFFSET=0
          elif [[ "${{ matrix.board }}" == *"esp32s2"* ]]; then
            CHIP_FAMILY="ESP32-S2"
            BOOTLOADER_OFFSET=4096  # 0x1000
          elif [[ "${{ matrix.board }}" == *"esp32c5"* ]] || [[ "${{ matrix.board }}" == *"XIAO_ESP32C5"* ]]; then
            # ESP32-C5 uses 0x2000 for bootloader | ESP32-C5 çš„ bootloader åç§»ä¸º 0x2000
            CHIP_FAMILY="ESP32-C5"
            BOOTLOADER_OFFSET=8192  # 0x2000
          elif [[ "${{ matrix.board }}" == *"esp32c3"* ]]; then
            CHIP_FAMILY="ESP32-C3"
            BOOTLOADER_OFFSET=0
          elif [[ "${{ matrix.board }}" == *"esp32c6"* ]]; then
            CHIP_FAMILY="ESP32-C6"
            BOOTLOADER_OFFSET=0
          elif [[ "${{ matrix.board }}" == *"esp32h2"* ]]; then
            CHIP_FAMILY="ESP32-H2"
            BOOTLOADER_OFFSET=0
          elif [[ "${{ matrix.board }}" == *"esp32"* ]]; then
            CHIP_FAMILY="ESP32"
            BOOTLOADER_OFFSET=4096  # 0x1000
          fi
          
          echo "Chip Family: ${CHIP_FAMILY}"
          echo "Bootloader Offset: ${BOOTLOADER_OFFSET}"
          echo "Boot App0 Offset: ${BOOT_APP0_OFFSET}"
          
          # Create manifest.json with all 4 binary files | åˆ›å»ºåŒ…å«æ‰€æœ‰ 4 ä¸ªäºŒè¿›åˆ¶æ–‡ä»¶çš„ manifest.json
          # Flash layout: bootloader -> partitions -> boot_app0 -> firmware
          # Flash å¸ƒå±€ï¼šbootloader -> partitions -> boot_app0 -> firmware
          cat > manifest.json << EOF
          {
            "name": "${{ matrix.firmware }}",
            "version": "1.0.0",
            "home_assistant_domain": "seeed_ha_discovery",
            "funding_url": "https://www.seeedstudio.com/",
            "new_install_prompt_erase": true,
            "new_install_improv_wait_time": 0,
            "builds": [
              {
                "chipFamily": "${CHIP_FAMILY}",
                "parts": [
                  { "path": "bootloader.bin", "offset": ${BOOTLOADER_OFFSET} },
                  { "path": "partitions.bin", "offset": ${PARTITIONS_OFFSET} },
                  { "path": "boot_app0.bin", "offset": ${BOOT_APP0_OFFSET} },
                  { "path": "firmware.bin", "offset": ${FIRMWARE_OFFSET} }
                ]
              }
            ]
          }
          EOF
          
          echo "Created manifest.json:"
          cat manifest.json

      - name: Upload firmware artifact
        uses: actions/upload-artifact@v4
        with:
          name: firmware-${{ matrix.firmware }}
          path: build/${{ matrix.firmware }}/
          retention-days: 30

  # Combine all firmware into one artifact | å°†æ‰€æœ‰å›ºä»¶åˆå¹¶åˆ°ä¸€ä¸ª artifact
  combine:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Download all firmware artifacts
        uses: actions/download-artifact@v4
        with:
          path: all-firmware/
          pattern: firmware-*

      - name: Reorganize firmware files
        run: |
          mkdir -p combined-firmware
          for dir in all-firmware/firmware-*; do
            firmware_name=$(basename "$dir" | sed 's/firmware-//')
            cp -r "$dir" "combined-firmware/$firmware_name"
          done
          
          echo "Combined firmware structure:"
          find combined-firmware -type f

      - name: Upload combined firmware
        uses: actions/upload-artifact@v4
        with:
          name: all-firmware
          path: combined-firmware/
          retention-days: 90

  # Create release (when manually triggered with release=true) | åˆ›å»ºå‘å¸ƒç‰ˆæœ¬ï¼ˆæ‰‹åŠ¨è§¦å‘ä¸” release=true æ—¶ï¼‰
  release:
    needs: combine
    if: github.event.inputs.release == 'true' || github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download combined firmware
        uses: actions/download-artifact@v4
        with:
          name: all-firmware
          path: firmware/

      - name: Create firmware index
        run: |
          cd firmware
          
          # Create index.json listing all available firmware | åˆ›å»ºåˆ—å‡ºæ‰€æœ‰å¯ç”¨å›ºä»¶çš„ index.json
          echo '[' > index.json
          first=true
          for dir in */; do
            firmware_name="${dir%/}"
            if [ "$first" = true ]; then
              first=false
            else
              echo ',' >> index.json
            fi
            echo "  {\"name\": \"$firmware_name\", \"manifest\": \"$firmware_name/manifest.json\"}" >> index.json
          done
          echo ']' >> index.json
          
          echo "Created index.json:"
          cat index.json

      - name: Get version and changelog
        id: version
        run: |
          VERSION=$(date +'%Y.%m.%d')-$(git rev-parse --short HEAD)
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          
          # Get the last release tag (if exists) | èŽ·å–ä¸Šä¸€ä¸ª release æ ‡ç­¾ï¼ˆå¦‚æžœå­˜åœ¨ï¼‰
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          
          # Generate changelog | ç”Ÿæˆæ›´æ–°æ—¥å¿—
          echo "Generating changelog..."
          if [ -n "$LAST_TAG" ]; then
            echo "Changes since $LAST_TAG:"
            CHANGELOG=$(git log ${LAST_TAG}..HEAD --pretty=format:"- %s (%h)" --no-merges | head -30)
          else
            echo "No previous tag found, using last 20 commits"
            CHANGELOG=$(git log --pretty=format:"- %s (%h)" --no-merges -20)
          fi
          
          # Save changelog to file (to handle multiline in GitHub Actions)
          # ä¿å­˜æ›´æ–°æ—¥å¿—åˆ°æ–‡ä»¶ï¼ˆå¤„ç† GitHub Actions ä¸­çš„å¤šè¡Œï¼‰
          echo "$CHANGELOG" > changelog.txt
          echo "Changelog generated:"
          cat changelog.txt

      - name: Package firmware for release
        run: |
          # Create zip files for each firmware to avoid filename conflicts
          # ä¸ºæ¯ä¸ªå›ºä»¶åˆ›å»º zip æ–‡ä»¶ä»¥é¿å…æ–‡ä»¶åå†²çª
          cd firmware
          
          for dir in */; do
            firmware_name="${dir%/}"
            echo "Packaging $firmware_name..."
            zip -r "${firmware_name}.zip" "$dir"
          done
          
          # Also create a combined zip with all firmware | åŒæ—¶åˆ›å»ºåŒ…å«æ‰€æœ‰å›ºä»¶çš„åˆå¹¶ zip
          cd ..
          zip -r "all-firmware.zip" firmware/
          mv all-firmware.zip firmware/
          
          echo "Created packages:"
          ls -la firmware/*.zip

      - name: Generate release body
        id: release_body
        run: |
          # Read changelog | è¯»å–æ›´æ–°æ—¥å¿—
          CHANGELOG=$(cat changelog.txt)
          
          # Create release body | åˆ›å»ºå‘å¸ƒè¯´æ˜Ž
          cat > release_body.md << 'ENDOFHEADER'
          ## ðŸš€ Firmware Release
          
          Pre-compiled firmware for Seeed HA Discovery devices.
          ä¸º Seeed HA Discovery è®¾å¤‡é¢„ç¼–è¯‘çš„å›ºä»¶ã€‚
          
          ### ðŸ“¥ How to Flash | å¦‚ä½•çƒ§å½•
          
          **Web Flasher (Recommended | æŽ¨è):**
          Visit [Web Flasher](https://limengdu.github.io/Seeed-Homeassistant-Discovery/flasher/) to flash directly from browser.
          è®¿é—® [ç½‘é¡µçƒ§å½•å™¨](https://limengdu.github.io/Seeed-Homeassistant-Discovery/flasher/) ç›´æŽ¥ä»Žæµè§ˆå™¨çƒ§å½•ã€‚
          
          ### ðŸ“¦ Included Firmware | åŒ…å«çš„å›ºä»¶
          
          | Firmware | Chip | Description |
          |----------|------|-------------|
          | IoTButtonV2_DeepSleep | ESP32-C6 | Low-power IoT button with deep sleep |
          | WiFiProvisioning | ESP32-C6 | WiFi provisioning demo |
          
          ### ðŸ“ Downloads | ä¸‹è½½
          
          - `all-firmware.zip` - All firmware in one package | æ‰€æœ‰å›ºä»¶åˆé›†
          - Individual firmware zip files available below | å•ç‹¬å›ºä»¶ zip æ–‡ä»¶å¦‚ä¸‹
          
          ### ðŸ“ Changelog | æ›´æ–°æ—¥å¿—
          
          ENDOFHEADER
          
          # Append changelog | æ·»åŠ æ›´æ–°æ—¥å¿—
          echo "$CHANGELOG" >> release_body.md
          
          # Add build info | æ·»åŠ æž„å»ºä¿¡æ¯
          cat >> release_body.md << ENDOFFOOTER
          
          ---
          
          **Build Info | æž„å»ºä¿¡æ¯:**
          - ESP32 Core Version: ${{ env.ESP32_CORE_VERSION }}
          - Build Date: $(date -u '+%Y-%m-%d %H:%M:%S UTC')
          - Commit: ${{ github.sha }}
          ENDOFFOOTER
          
          echo "Release body generated:"
          cat release_body.md

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: firmware-${{ steps.version.outputs.version }}
          name: Firmware Release ${{ steps.version.outputs.version }}
          body_path: release_body.md
          files: |
            firmware/*.zip

